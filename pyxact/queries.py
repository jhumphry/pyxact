'''This module defines Python types that describe SQL queries.'''

import re
from . import dialects, fields, records, recordlists

CONTEXT_PLACEHOLDER_REGEXP = re.compile(r'\{[^\}]*\}')

class SQLQueryMetaClass(type):
    '''This metaclass ensures that SQLQuery is only subclassed with a
    valid SQLRecord subclass as the record_type parameter.'''

    def __new__(mcs, name, bases, namespace, query='',
                record_type=None, recordlist_type=None, **kwds):

        if record_type:
            if not isinstance(record_type, type):
                raise ValueError('record_type must refer to an SQLRecord subclass.')
            if not issubclass(record_type, records.SQLRecord):
                raise ValueError('record_type must refer to an SQLRecord subclass.')
        namespace['_record_type'] = record_type

        if recordlist_type:
            if not isinstance(recordlist_type, type):
                raise ValueError('recordlist_type must refer to an SQLRecordList subclass.')
            if not issubclass(recordlist_type, recordlists.SQLRecordList):
                raise ValueError('recordlist_type must refer to an SQLRecordList subclass.')
            if not issubclass(record_type, recordlist_type._record_type):
                raise ValueError('recordlist_type must be able to hold instances of the '
                                 'record_type parameter.')
        namespace['_recordlist_type'] = recordlist_type

        # Now identify the SQLField attached to the new class to form the context for
        # the query
        slots = []
        _context_fields = dict()
        for k in namespace:
            if isinstance(namespace[k], fields.SQLField):
                if k in INVALID_SQLQUERY_ATTRIBUTE_NAMES:
                    raise AttributeError('SQLField {} has the same name as an SQLQuery'
                                         ' method or internal attribute'.format(k))
                slots.append('_'+k)
                _context_fields[k] = namespace[k]
        namespace['_context_fields'] = _context_fields
        namespace['__slots__'] = slots

        # Now process the query text to extract placeholders and check they
        # correspond to actual context fields.
        segmented_query = []
        query_fields = []
        current_pos = 0
        match = CONTEXT_PLACEHOLDER_REGEXP.search(query, pos=current_pos)
        if match:
            while match:
                field = match.group(0)[1:-1]
                if field not in _context_fields:
                    raise AttributeError('Query placeholder {} does not match any of the '
                                         'context fields'.format(field))
                query_fields.append(field)
                segmented_query.append(query[current_pos:match.start()])
                current_pos = match.end()
                match = CONTEXT_PLACEHOLDER_REGEXP.search(query, pos=current_pos)
        segmented_query.append(query[current_pos:])
        namespace['_query'] = query
        namespace['_segmented_query'] = segmented_query
        namespace['_query_fields'] = query_fields

        return type.__new__(mcs, name, bases, namespace)

class SQLQuery(metaclass=SQLQueryMetaClass,
               query='',
               record_type=None,
               recordlist_type=None):
    '''SQLQuery maps an SQL query to Python class types. It is not intended
    for direct use, but as an abstract class to be subclassed. The query string
    passed to it can have placeholders indicated by text such as {foo}. When
    the query SQL is generated by the query_sql method these will be replaced
    by the placeholder string used by the relevant database adaptor dialect.
    The method query_values_sql_repr will return the extract the values from
    the SQLField class attributes of the same name (here, a SQLField in the
    SQLQuery subclass named 'foo') in the correct order to be passed to the
    database alongside the query text.'''

    def __init__(self, *args, **kwargs):

        for i in self.__slots__:
            setattr(self, i, None)

        if args:
            if len(args) != len(self._context_fields):
                raise ValueError('{0} values required, {1} supplied.'
                                 .format(len(self._context_fields), len(args)))

            for field, value in zip(self._context_fields.keys(), args):
                setattr(self, field, value)

        elif kwargs:
            for key, value in kwargs.items():
                if key not in self._context_fields:
                    raise ValueError('{0} is not a valid attribute name.'.format(key))
                setattr(self, key, value)

    def get_context(self):
        '''Return a context dictionary created from the values stored under the
        names of the SQLField objects directly attached as attributes to the
        SQLQuery.'''

        result = dict()
        for i in self._context_fields:
            result[i] = getattr(self, i)
        return result

    def query_values(self):
        '''Return a correctly-ordered list of the values that need to be passed
        to the database to execute the query.'''

        return [getattr(self, i) for i in self._query_fields]

    def query_values_sql_repr(self, dialect=None):
        '''Return a correctly-ordered list of the values that need to be passed
        to the database to execute the query, using the appropriate SQL adaptor
        dialect.'''

        if dialect is None:
            dialect = dialects.DefaultDialect

        return [dialect.sql_repr(getattr(self, i)) for i in self._query_fields]

    @classmethod
    def query_sql(cls, dialect=None):
        '''Return the SQL query text using the correct placeholder for the SQL
        dialect in use.'''

        if dialect is None:
            dialect = dialects.DefaultDialect
        return dialect.placeholder.join(cls._segmented_query)

    def execute(self, cursor, dialect=None):
        '''Execute the query using the cursor.'''

        if dialect is None:
            dialect = dialects.DefaultDialect
        cursor.execute(self.query_sql(dialect), self.query_values_sql_repr())

    @classmethod
    def result_records(cls, cursor):
        '''Take a database cursor with an executed query and for each row
        returned by this query, yield an instance of the SQLRecord subclass
        specified via record_type when SQLQuery was subclassed.'''

        if not cls._record_type:
            raise RuntimeError('This SQLQuery subclass does not have an associated SQLRecord '
                               'result class specified.')

        next_row = cursor.fetchone()
        while next_row:
            yield cls._record_type(*next_row)
            next_row = cursor.fetchone()

    @classmethod
    def result_recordlist(cls, cursor):
        '''Take a database cursor with an executed query and return an instance
        of the SQLRecordList subclass specified when SQLQuery was
        subclassed.'''

        if not cls._recordlist_type:
            raise RuntimeError('This SQLQuery subclass does not have an associated SQLRecordList '
                               'result class specified.')

        return cls._recordlist_type((cls._record_type(*x) for x in cursor.fetchall()))

    @staticmethod
    def result_singlevalue(cursor):
        '''Take a database cursor with an executed query that returns a single
        value and return just that value.'''

        result_row = cursor.fetchone()

        if len(result_row) != 1:
            raise ValueError('The query returned more than one value.')

        return result_row[0]

INVALID_SQLQUERY_ATTRIBUTE_NAMES = frozenset(dir(SQLQuery))

class QueryIntField(fields.IntField):
    '''Represents an context field in an SQLTransaction that has a link to an
    SQLQuery. It can be retrieved and set as a normal SQLField. When
    get_new_context is called on the SQLTransaction the query will be executed
    with the current context dictionary (i.e. the values of the context fields
    prior to the QueryField) being used to set the parameters of the query. The
    single value result returned will be added to the context dictionary under
    the name of the QueryField. Within SQLRecord subclasses attached to the
    SQLTransaction, an IDIntField can be used to mirror this value. This field
    type has no direct use inside an SQLRecord.'''

    def __init__(self, query, **kwargs):

        if not issubclass(query, SQLQuery):
            raise ValueError('Query provided must be a subclass (not instance) of '
                             'pyxact.queries.SQLQuery')

        self.query = query
        super().__init__(**kwargs)

    def update(self, instance, context, cursor, dialect=None):

        query = self.query(**context)
        query.execute(cursor, dialect)
        value = query.result_singlevalue(cursor)
        setattr(instance, self._slot_name, self.convert(value))
        return value
