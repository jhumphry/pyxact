'''This module defines Python types that describe SQL queries.'''

import re
from . import dialects, fields, records

CONTEXT_PLACEHOLDER_REGEXP = re.compile(r'\{[^\}]*\}')

class SQLQueryMetaClass(type):
    '''This metaclass ensures that SQLQuery is only subclassed with a
    valid SQLRecord subclass as the record_type parameter.'''

    def __new__(mcs, name, bases, namespace, query='', record_type=None, **kwds):

        # First, establish the record type
        if not isinstance(record_type, type):
            raise ValueError('record_type parameter must refer to an SQLRecord subclass.')
        if not issubclass(record_type, records.SQLRecord):
            raise ValueError('record_type parameter must refer to an SQLRecord subclass.')
        namespace['_record_type'] = record_type

        # Now identify the SQLField attached to the new class to form the context for
        # the query
        slots = []
        _context_fields = dict()
        for k in namespace:
            if isinstance(namespace[k], fields.SQLField):
                if k in INVALID_SQLQUERY_ATTRIBUTE_NAMES:
                    raise AttributeError('SQLField {} has the same name as an SQLQuery'
                                         ' method or internal attribute'.format(k))
                slots.append('_'+k)
                _context_fields[k] = namespace[k]
        namespace['_context_fields'] = _context_fields
        namespace['__slots__'] = slots

        # Now process the query text to extract placeholders and check they
        # correspond to actual context fields.
        segmented_query = []
        query_fields = []
        current_pos = 0
        match = CONTEXT_PLACEHOLDER_REGEXP.search(query, pos=current_pos)
        if match:
            while match:
                field = match.group(0)[1:-1]
                if field not in _context_fields:
                    raise AttributeError('Query placeholder {} does not match any of the '
                                         'context fields'.format(field))
                query_fields.append(field)
                segmented_query.append(query[current_pos:match.start()])
                current_pos = match.end()
                match = CONTEXT_PLACEHOLDER_REGEXP.search(query, pos=current_pos)
            segmented_query.append(query[current_pos:])
        else:
            segmented_query.append(query)
        namespace['_query'] = query
        namespace['_segmented_query'] = segmented_query
        namespace['_query_fields'] = query_fields

        return type.__new__(mcs, name, bases, namespace)

class SQLQuery(metaclass=SQLQueryMetaClass,
               query='',
               record_type=records.SQLRecord):
    '''SQLRecord maps an SQL query to Python class types. It is not intended
    for direct use, but as an abstract class to be subclassed. The query string
    passed to it can have placeholders indicated by text such as {foo}. When
    the query SQL is generated by the query_sql method these will be replaced
    by the placeholder string used by the relevant database adaptor dialect.
    The method query_values_sql_repr will return the extract the values from
    the SQLField class attributes of the same name (here, a SQLField in the
    SQLQuery subclass named 'foo') in the correct order to be passed to the
    database alongside the query text.'''

    def __init__(self, *args, **kwargs):

        for i in self.__slots__:
            setattr(self, i, None)

        if args:
            if len(args) != len(self._context_fields):
                raise ValueError('{0} values required, {1} supplied.'
                                 .format(len(self._context_fields), len(args)))

            for field, value in zip(self._context_fields.keys(), args):
                setattr(self, field, value)

        elif kwargs:
            for key, value in kwargs.items():
                if key not in self._context_fields:
                    raise ValueError('{0} is not a valid attribute name.'.format(key))
                setattr(self, key, value)

    def get_context(self):
        '''Return a context dictionary created from the values stored under the
        names of the SQLField objects directly attached as attributes to the
        SQLQuery.'''

        result = dict()
        for i in self._context_fields:
            result[i] = getattr(self, i)
        return result

    def query_values(self):
        '''Return a correctly-ordered list of the values that need to be passed
        to the database to execute the query.'''

        return [getattr(self, i) for i in self._query_fields]

    def query_values_sql_repr(self, dialect=None):
        '''Return a correctly-ordered list of the values that need to be passed
        to the database to execute the query, using the appropriate SQL adaptor
        dialect.'''

        if dialect is None:
            dialect = dialects.DefaultDialect

        return [dialect.sql_repr(getattr(self, i)) for i in self._query_fields]

    @classmethod
    def query_sql(cls, dialect=None):
        '''Return the SQL query text using the correct placeholder for the SQL
        dialect in use.'''

        if dialect is None:
            dialect = dialects.DefaultDialect
        return dialect.placeholder.join(cls._segmented_query)

    @classmethod
    def query_result(cls, cursor):
        '''Take a database cursor with an active query and for each row returned
        by this query, yield an instance of the SQLRecord subclass specified via
        record_type when SQLQuery was subclassed.'''

        next_row = cursor.fetchone()
        while next_row:
            yield cls._record_type(*next_row)
            next_row = cursor.fetchone()

    def execute_query(self, cursor, dialect=None):
        '''Execute the query using the cursor and return a generator that
        yields each row of the result cast into one instance of the SQLRecord
        subclass specified when the query class was defined.'''

        if dialect is None:
            dialect = dialects.DefaultDialect
        cursor.execute(self.query_sql(dialect), self.query_values_sql_repr())
        yield from self.query_result(cursor)

INVALID_SQLQUERY_ATTRIBUTE_NAMES = frozenset(dir(SQLQuery))
